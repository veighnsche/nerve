# nrv.apply (diff application primitives)

## Purpose
- Provide deterministic helpers for applying textual diffs to files under user control (ADR-006).
- Enable LLM-generated patches to be materialised without hidden mutation, preserving proof capture and audit logs.

## Scope
- Applies **line-oriented unified diffs** generated by the user or an LLM.
- Handles single-file patches; multi-file diffs MUST be split by the caller.
- Binary patches and merge conflict markers are out of scope. Zero-context diffs are strongly discouraged;
  M1 may accept them but they reduce robustness and are not recommended for production.

## Implementation Status (M1)
- `nrv_rs::apply::diff` is implemented with `diffy` and covers single-file unified diffs.
- M1 allows creating a new file when the diff adds content (no explicit `Create` strategy yet).
- M1 writes directly via `fs::write` (no temp-file + atomic rename yet).
- Header paths in `---/+++` are ignored for filesystem lookup and not validated.
  
See also the userland scaffolding helpers in `.specs/15_llama_orch_toolkit.md` for plan→apply flows.

## Surface (initial)
- `apply.diff(options)` (async in JS/TS, fallible function in Rust).
  - `options.path: Path` — absolute or workspace-relative path to the target file.
  - `options.diff: string` — unified diff matching the target file on disk.
  - `options.strategy?: ApplyStrategy` — default `ApplyStrategy::Write`.
  - `options.checksum?: string` — optional SHA-256 of the pre-image for race protection.
- Returns `ApplyOutcome` with:
  - `status: "applied" | "noop"`.
  - `hunks_applied: number`.
  - `warnings?: string[]` (non-fatal notices).
- Errors map to structured variants (`DiffParseError`, `ChecksumMismatch`, `HunkRejection`, `IoError`).

### `ApplyStrategy`
- `Write` — apply patch in-memory then write to disk.
- `DryRun` — validate patch without writing; returns `status: "noop"` with `hunks_applied`.
- `WriteBackup { backup_suffix: String }` — write and persist pre-image alongside (e.g., `.bak`).

## Diff Requirements
- Unified diff MUST include `---`/`+++` headers with the target path (ignored for filesystem lookup).
- Hunks SHOULD carry context lines; zero-context diffs MAY be accepted in M1 but are discouraged for robustness.
- Patches MUST be sorted in ascending hunk order; overlapping hunks are an error.
- Line endings MUST remain untouched unless modified by the diff.
- File encodings MUST be UTF-8; other encodings are rejected until explicitly supported.

## Behavioural Requirements
- Operations MUST be synchronous per file (no hidden parallel writes).
- The engine MUST load the current file contents, apply hunks in memory, then persist when `strategy` writes.
- Atomic persistence (temp-file + rename) is a SHOULD for production; M1 uses direct writes.
- `checksum`, when provided, MUST match the SHA-256 of the current file before applying; mismatch = `ChecksumMismatch`.
- When the target file does not exist and the diff creates content, M1 applies the diff and creates the file.
  A future `Create` strategy will make creation explicit.
- Conflicting hunks MUST abort the operation; partial application is not allowed.
- `DryRun` MUST return the same rejection errors as `Write` without touching disk.

## Error Semantics
- `InvalidDiff { message }` — invalid unified diff structure or hunk rejection (M1 mapping from parser).
- `ChecksumMismatch { expected, actual }` — file changed since diff creation.
- `InvalidUtf8 { path }` — target file contains invalid UTF-8 (M1 constraint).
- `Io { operation, path, source }` — filesystem failure (surface errno in message).
- Errors MUST propagate to callers without retries or silent fixes.

## Observability & Proofs
- Each invocation SHOULD emit `ApplyEvent` entries (path, strategy, status, checksum, duration)
  for proof bundles.
- Warnings (e.g., trimmed trailing newline) MUST be surfaced to callers.

## Cross-Language Parity
- Rust: exposed via `nrv_rs::apply::diff(options) -> Result<ApplyOutcome, ApplyError>`.
- JS/TS: exposed via `await nrv.apply.diff(options)` returning `{ status, hunksApplied, warnings? }`.
- Shared schema MUST stay defined in this spec; any divergence requires updating both bindings and docs.

## Testing Strategy
- Unit tests: parse diff, checksum validation, overlapping hunk rejection, dry-run semantics.
- Integration tests: apply diff to fixture file, verify backup strategy, confirm atomic writes.
- Fuzz tests (future): randomised hunk inputs to harden parser (tracked in `todo.md`).

## Next Steps
- Implement diff parser/engine in Rust with parity TS binding on top.
- Extend CLI (`nrv apply diff`) once core primitive stabilises (separate spec update).
- Document diff authoring guidance in `.specs/00_nerve.md` under apply workflows.
