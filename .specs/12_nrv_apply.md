# nrv.apply (diff application primitives)

## Purpose
- Provide deterministic helpers for applying textual diffs to files under user control (ADR-006).
- Enable LLM-generated patches to be materialised without hidden mutation, preserving proof capture and audit logs.

## Scope
- Applies **line-oriented unified diffs** generated by the user or an LLM.
- Handles single-file patches; multi-file diffs MUST be split by the caller.
- Binary patches, context-less diffs, and merge conflict markers are out of scope.

## Surface (initial)
- `apply.diff(options)` (async in JS/TS, fallible function in Rust).
  - `options.path: Path` — absolute or workspace-relative path to the target file.
  - `options.diff: string` — unified diff matching the target file on disk.
  - `options.strategy?: ApplyStrategy` — default `ApplyStrategy::Write`.
  - `options.checksum?: string` — optional SHA-256 of the pre-image for race protection.
- Returns `ApplyOutcome` with:
  - `status: "applied" | "noop"`.
  - `hunks_applied: number`.
  - `warnings?: string[]` (non-fatal notices).
- Errors map to structured variants (`DiffParseError`, `ChecksumMismatch`, `HunkRejection`, `IoError`).

### `ApplyStrategy`
- `Write` — apply patch in-memory then write to disk.
- `DryRun` — validate patch without writing; returns `status: "noop"` with `hunks_applied`.
- `WriteBackup { backup_suffix: String }` — write and persist pre-image alongside (e.g., `.bak`).

## Diff Requirements
- Unified diff MUST include `---`/`+++` headers with the target path (ignored for filesystem lookup).
- Hunks MUST carry context lines; zero-context diffs are rejected.
- Patches MUST be sorted in ascending hunk order; overlapping hunks are an error.
- Line endings MUST remain untouched unless modified by the diff.
- File encodings MUST be UTF-8; other encodings are rejected until explicitly supported.

## Behavioural Requirements
- Operations MUST be synchronous per file (no hidden parallel writes).
- The engine MUST load the current file contents, apply hunks in memory, then persist atomically
  (write temp + rename) when `strategy` writes.
- `checksum`, when provided, MUST match the SHA-256 of the current file before applying; mismatch = `ChecksumMismatch`.
- When the target file does not exist and the diff creates content, the operation MUST fail unless a future
  `Create` strategy is introduced.
- Conflicting hunks MUST abort the operation; partial application is not allowed.
- `DryRun` MUST return the same rejection errors as `Write` without touching disk.

## Error Semantics
- `DiffParseError { line, message }` — invalid unified diff structure.
- `ChecksumMismatch { expected, actual }` — file changed since diff creation.
- `HunkRejection { hunk_index, reason }` — content mismatch or overlap.
- `IoError { path, message }` — filesystem failure (surface errno in message).
- Errors MUST propagate to callers without retries or silent fixes.

## Observability & Proofs
- Each invocation SHOULD emit `ApplyEvent` entries (path, strategy, status, checksum, duration)
  for proof bundles.
- Warnings (e.g., trimmed trailing newline) MUST be surfaced to callers.

## Cross-Language Parity
- Rust: exposed via `nrv_rs::apply::diff(options) -> Result<ApplyOutcome, ApplyError>`.
- JS/TS: exposed via `await nrv.apply.diff(options)` returning `{ status, hunksApplied, warnings? }`.
- Shared schema MUST stay defined in this spec; any divergence requires updating both bindings and docs.

## Testing Strategy
- Unit tests: parse diff, checksum validation, overlapping hunk rejection, dry-run semantics.
- Integration tests: apply diff to fixture file, verify backup strategy, confirm atomic writes.
- Fuzz tests (future): randomised hunk inputs to harden parser (tracked in `todo.md`).

## Next Steps
- Implement diff parser/engine in Rust with parity TS binding on top.
- Extend CLI (`nrv apply diff`) once core primitive stabilises (separate spec update).
- Document diff authoring guidance in `.specs/00_nerve.md` under apply workflows.
